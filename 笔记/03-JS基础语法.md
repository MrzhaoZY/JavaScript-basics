# 1-变量

### 1.1  变量

是一个装（数据）东西的容器

### 1.2 变量在内存中的存储

本质： 变量是程序在内存中申请的一块用来存放数据的空间

### 1.3 变量的使用

1.声明变量  2.赋值

var age;



### 1.4 数据类型

#### 1.4.1 变量的数据类型

**JavaScript是一种弱类型或者说动态语言**， 这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。



#### **1.4.2 数据类型**

分为  简单数据类型（基本数据类型）+ 复杂数据类型（object）

简单数据类型==> 

*<u>①number</u>* 数字型 （整型 小数）  

Number.MAX_VALUE 数字型的最大值

Number.MIN_VALUE 数字型的最小值

<!--数字型的三个特殊值-->

<!--无穷大  ==> Infinity-->

<!--无穷小 ==> -Infinity-->

<!--非数值 ==> NaN-->



②boolean   布尔类型 (true  false)

③string  字符串



④undefined   未定义数据类型（声明未赋值）

`<!--特殊：-->`

​			`<!--var variable = undefined;-->`

​			`<!--console.log(variable+ 'hello');   ==>  undefinedhello-->`

​			`<!--console.log(variable + 1);			==> NaN-->`

⑤null	空值



#### **1.4.3 数据类型转换**

转换为字符串： 

 1)  	  var num = 10;

 			var str = num.toString();

 2) 强制转换  var num =10;

​						console.log(String(num));

 3）隐式转换  拼接一个字符串  + ‘ ’



转换为数字型

​	①  parseInt（）

​	var age = prompt ('请输入你的年龄：');

​    console.log(parseInt(age));  

// 可以把字符型转换为数字型  得到的是整型  ； 如果是小数  只	取到整数部分  ； 如果带单位 120 px  会去掉这个单位 得到120

② parseFloat()

可以把字符型的转换为数字型，得到的是小数 浮点数

③Number

var str = '123';

console.log(Number(str));

④隐式转化   - * / 

console.log('12' - 0); // 12     console.log('12' * 1);  console.log('12' / 1);

console.log('123' - '120'); //3

转换为布尔型

Boolean()函数

代表空、否定的值会被转换为false 其余的都为true



# 2-标识符、关键字、保留字

### 2.1 标识符

标识符： 就是指开发人员为变量、属性、函数、参数取的名字。

- ​	<u>标识符不能是关键字或保留字</u>	

### 2.2 关键字

关键字： 是指JS本身已经使用了的字，不能再用它们充当变量名，方法名

### 2.3 保留字

保留字： 实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们充当变量名或方法名。



# 3-运算符

### 3.1 运算符

​		operator 也称操作符，是用来实现赋值，比较和执行运算等功能的符号。

JavaScript中常见的运算符有：

- 算数运算符

- 递增和递减运算符

- 比较运算符

- 逻辑运算符

- 赋值运算符

### 3.2 算数运算符

‘+’   ‘-’   ‘ *’  ‘ /’  '%'

% : 取模/ 取余

先乘除 后加减  有小括号先算小括号里面的

##### 问题：

 浮点数 算数运算里面会有问题

console.log(0.1 + 0.2);  ==>  0.30000000000004

console.log(0.3 * 10); ==> 3.000000000001

我们不能直接拿浮点数想比较  尽量避开浮点数

### 3.3 递增递减运算符

递增++

递减 --

<!--递增和递减必须和变量配合使用-->

前置： 先加减1  后返回值

后置： 先返回值 后加减1

​	`var b = 10;`

​    `var c = b++ + ++b;`

​    `console.log(c); // 22`



### 3.4 比较运算符

​		比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个**布尔值**（true/false）作为比较运算的结果。

> <    >   >=  <=  ==   !=   ===(全等  数据类型和数值完全相等)    !==
>
> + 我们程序里面的等于号 == 默认转换数据类型 会把字符串型的数据转换为数字型

### 3.5 逻辑运算符

​		逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断

> - && ==> ‘逻辑与’ 简称 ‘与’   and      <!--例：true && false-->      一假即假
>
> - ||  ==> '逻辑或' 简称 '或' or   	<!--例: true || false-->       一真为真
>
> -  ! ==> '逻辑非' 简称 '非'   not           <!--例： !-->
>
>   真为假     假为真
>
>   
>
>   - 短路运算（逻辑中断）
>
>   原理：当有多个表达式（值），左边的表达式可以确定结果时，就不再继续运算右边的表达式的值
>
>   + + + I   与运算： 如果表达式1为真 ，就返回表达式2 ；如果表达式1位假，则返回表达式2；如果有空的或者否定的为假 其余是真的
>       + II或运算： 如果表达式1为真，就返回表达式1；如果表达式1为假，就返回表达式2；
>   
> - `var num = 0;`
>
>   `console.log(123 || num++);    //123 为真，逻辑中断 num++不执行`
>
>   `console.log(num);   //此时的num为0`



### 3.6 赋值运算符

​		用来把数据赋值给变量的运算符

> num = num + 1; ==>  num++;
>
> num = num + 2; ==> num += 2;
>
> age = age * 2; ==> age *= 2;



### 3.7 运算符优先级

> ​	()   >  一元运算符 ++、-- 、！  >   算数运算符  * / %  + -  >  关系运算符 > >= < <=     >     相等运算符 == != === !==      >   逻辑运算符  先&& 后||     >    赋值运算符 =      >       逗号运算符 ,
>
> + + 一元运算符里面的逻辑非优先级很高





# 4-流程控制

​		流程控制就是控制 我们的代码按照什么结构顺序来执行

### 4.1 顺序结构

​		最简单最基本的流程控制，按照代码的先后顺序依次执行

### 4.2 分支流程控制

​		从上到下执行代码的控制中，根据不同的条件，执行不同的代码，从而得到不同的效果

> - if 语句
>
>   i`f(条件表达式){`
>
>   ​		`//执行语句`
>
>   ​		`//如果条件表达式为真，那么执行{}里面的语句，如果条件表达式为假，那么不执行。`
>
>   `}`  
>
>   
>
>   `if(条件表达式){`
>
>   ​			`//语句1`
>
>   `}else{`
>
>   ​			`//语句2`
>
>   ​			`//如果条件表达式为真，那么执行语句1，否则执行语句2`
>
>   `}`
>
>   
>
>   `if(条件1){`
>
>   `}else if(条件2){`
>
>   `}else if(条件3){`
>
>   `}else{`
>
>   `}`
>
>   
>
>   
>
> - 三元表达式：
>
>   条件表达式 ?  表达式1的值 ：表达式2的值;
>
>   var max = a>b?a:b;
>
>   
>
> - switch语句：
>
>   switch语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用switch
>
>   - 利用表达式的值 和 case后面的值相匹配，如果匹配上，就执行case里面的语句，如果都没有匹配上就执行default里面的值
>
>   `switch (表达式：){`
>
>   ​	//表达式的值需要与case的value值全等才能相匹配
>
>   ​	//如果当前的case里面没有 break，则不会跳出switch，会继续执行下一个case里面的语句。
>
>   ​      `case value1:`
>
>   ​        `//执行语句；`
>
>   ​        `break;`
>
>   ​      `case value2:`
>
>   ​        `//执行语句；`
>
>   ​        `break;`
>
>   ​      `case value3:`
>
>   ​        `//执行语句；`
>
>   ​        `break;`
>
>   ​      `...`
>
>   ​      `default:`
>
>   ​        `//执行最后的语句；`
>
>   ​    `}`



- - - **switch语句 和 if else if 语句的区别**：

    ①一般情况下，它们两个可以相互替换

    ②switch...case语句通常处理case为比较确定值的情况，而if...else...语句更加灵活，常用于范围判断（大于，等于某个范围）

    ③switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if...else 语句有几种条件，就得多判断几次。

    ④当分支比较少的情况下，if...else 语句执行的效率比 switch 语句高

    ⑤当分支比较多的情况下，switch 语句的执行效率比较高，而且结构更清晰

### 4.3 循环流程控制

>  循环的目的： 重复执行某些代码

#### 1.for循环

​		一组被重复执行的语句被称之为 循环体， 能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称之为 循环语句。



- 语法结构：

  ​	for(初始化变量; 条件表达式; 操作表达式){

  ​		循环体

  }

  `for (var i = 0; i < 100; i++) {`

  ​      `console.log(i);`

  ​    `}`

  

  `// 例：求1~100的累加和.`

  `var num = 0;`

  ​    `for(var i = 0; i <= 100; i++) {`

  ​      `num +=i;`

  ​    `}`

​    `console.log("num = "+num);`



​	`双重for循环`

​		`for(var i =0; i < 10; i++){`

​			`for(var j = 0; j < i; j++){`

​				`//循环体`		

​		`}`

`}`



#### 2.while循环

​		

> while (条件表达式){
>
> ​		// 循环体
>
> ​		//当条件表达式的结果为true时，则执行循环体 否则 退出循环
>
> }

<script>
        var num = 1;
        while (num <= 100){
            console.log(num);
            num++;
        }
    </script>



#### 3.do while 循环

​		do while 该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环

<script>
    do{
		//循环体
        //do while 循环体至少执行一次
    }while(条件表达式)
</script>



- + continue 关键字

    用于立即跳出本次循环，进行下一次循环

  + break      关键字

    用于立即跳出整个循环（循环结束)



# 5- 命名规范以及语法格式

#### 标识符命名规范

- 变量、函数的命名必要要有意义

- 操作符的左右两侧尽量有空格
- 单行注释 
- 其它规范（＋空格）



# 6-数组

### 6.1 数组的概念

> 数组就是一组数据的集合, 其中每个数据被称为元素, 在数组中可以存放任意类型的元素, 数组是一种将一组数据存储在单个变量名下的优雅方式.

### 6.2 创建数组

<script>
    	//1.利用new 创建数组
        var arr1 = new Array();
    	//2.利用数组字面量创建数组
    	var arr2 = []; 
    	var arr3 = [1,2,3,4]
        //[]里面可以直接存放任意类型的数据
        // 数组元素 之间用逗号分隔
</script>

### 6.3 获取数组元素

##### 6.3.1 数组的索引

​		索引（下标） : 用来访问数组元素的序号（数组元素的索引从 0 开始）

<script>
    var arr = [1,2,3,4];
    console.log(arr[1]); // 
    console.log(arr[5]); // 如果数组里面没有这个元素，那么输出的结果是 undefined 
</script>



### 6.4 遍历数组

> 遍历： 就是把数组中的每个元素都访问一遍

<script>
    var arr2 = [1,2,3,4,5,6,,7,8];
    for(var i = 0; i < arr2.length; i++) {
            console.log(arr2[i]);
        }
</script>

- 数组长度： 元素的个数

   	数组名.length   ==>  动态检测数组元素的个数



### 6.5 数组中新增元素

##### 6.5.1 通过修改length 长度新增数组元素

- 可以通过修改length长度来实现数组扩容的目的
- length 属性是可读写的

##### 6.5.2 新增数组元素 新增索引号 追加数组元素

<script>
    var arr = [1,2,3,4];
    console.log(arr);
    arr[4] = 5;
    console.log(arr);
    arr[1] = 6;   // 这里的arr[1] 原来的2会被覆盖掉
    console.log(arr)

    //如果直接给数组名添加元素 否则里面的数组元素就都没有了
    arr = 'hha';

</script>



# 7-函数

> 函数就是封装了一段可被重复调用执行的代码块，通过此代码块可以实现大量代码的重复使用

<script>
    function 函数名(参数){
        //代码块
    }
</script>

### 7.1 函数的使用

- 函数的声明

  ​	//函数名一般是动词

  ​	function 函数名(){

  }

- 函数的调用

  ​	//函数只声明，不调用的话，自己不执行

  函数名（）;

### 7.2 函数的封装

> ​	函数的封装就是一个或者多个功能通过 函数的方式封装起来，对外只提供一个简单的函数接口。（打包）



<script>
    // num1~num2 的和
    function getSum(num1,num2) {
        var sum = 0;
        for (var i = num1; i < num2; i++) {
            sum += i;
        }
        console.log(sum);
    }
</script>



### 7.3 函数的参数

> 函数的参数可以分为 形参 和 实参。
>
> 函数声明：function 函数名(形参1，形参2){}   //形参接受实参的，类似于变量  ==>  形参1 = 实参1；
>
> 函数调用：函数名（实参1，实参2）;

- 函数的参数可以有（个数不限)，也可以没有



<!--参数的作用： 在函数内部某些值不固定，我们可以通过调用函数时传递不同的值进去-->



- - 函数形参实参多个数匹配

<script>
        function getSum(num1, num2){
            console.log(num1 + num2);
        }
        // 1. 如果实参的个数和形参的个数一致，则正常输出结果
        getSum(1,3);



        //2. 如果实参的个数大于形参的个数， 会取到形参的个数
        getSum(1,3,2);

        //3. 如果实参的个数小于形参的个数
        形参可以看做是不用声明的变量 num2 是一个变量但是			没有接受值， 结果就是undefined
        getSum(1);  // NaN

        // 建议尽量让形参和实参的个数相等
    </script>



### 7.4 函数的返回值

##### 7.4.1 return 语句

> return 语句可以将函数的返回值 返回给调用者

<script>
    // 1. 求a + b 的和
        function getSum(a, b){
            return a + b;
        }
        console.log(getSum(1,2));

```html
    // 2. 求两个数的最大值
    function getMax(a, b) {
        return a > b ? a : b;
    }
    alert(getMax(2,3));

    // 3. 求数组中的最大值
    function getArrMax(arr) {
        var max = arr[0];
        for (var i = 1; i < arr.length; i++){
            max = max > arr[i] ? max : arr[i];
        }
        return max;
    }
    var arr = [1,6,4,7,2,4,67,24,534,12,87,24];
    var m = getArrMax(arr);  // 在实际开发中， 我们经常用一个变量名来接受函数返回的结果
    alert('该数组中的最大值是：'+m);
```
</script>

##### 7.4.2 return 终止函数

> ​	函数体里面， return 后面的代码不会被执行。

##### 7.4.3 return 的返回值

> ​	return 只能返回一个值， 如果用逗号隔开多个值， 以最后一个为准。
>
> - 如果想要输出多个结果，可以采用输出数组的方式来实现
>
> <script>
>     //比如想要输出a与b 的加减乘除结果
>     function getResult(a,b) {
>         return [a + b, a - b, a * b, a / b];
>     }
>     var abResult = getResult(3,2);
>     alert(abResult);
> </script>
>
> - 如果函数有返回值，那就返回该值，如果没有返回值，那么返回undefined

##### 7.4.4 break, continue, return的区别

- break:	结束当前的循环体
- continue：   跳出本次循环，继续执行下次循环
- return：  不仅可以退出循环，还能返回return 值，同时还可以结束当前的函数体内的代码。

### 7.5 arguments的使用

> ​		只有函数有arguments， 每个函数都内置了这个arguments
>
> ​		当我们不确定有多少个参数传递的时候，可以用arguments来获取， 在JavaScript中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参。

arguments 展示形式是一个伪数组， 因此可以进行遍历。伪数组具有以下特点：

- 具有length 属性
- 按索引方式存储数据
- 没有真正数组的一些方法，不具有数组的push,pop等方法



### 7.6 函数互相调用

### 7.7 函数的两种声明

- 1.利用函数关键字自定义函数（命名函数）

- 2.函数表达式 （匿名函数）

  `var 变量名 = function(){};`

  `var fun = function(){	// fun是变量名，不是函数名`

  ​		`//代码块`

  `}`

  `fun();`

  `// 函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值 而 函数表达式里面存的是函数`

  `// 函数表达式也可以传递参数`



# 8-作用域

###  8.1作用域概述

> ​		通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性代码范围 就是这个名字的作用域。 作用域的使用提高了程序逻辑的局部性，减少了名字冲突。

- js的作用域（es6）:全局作用域    局部作用域
  - 全局作用域： 整个script 标签 或者是一个单纯的js文件
  
  - 局部作用域(函数作用域)：在函数内部就是局部作用域， 这个代码的名字只在函数内部起效果和作用。
  
### 8.2变量的作用域

     根据作用域的不同，变量可以分为全局变量 和 局部变量

<!--全局变量：   如果在函数内部没有声明，直接赋值的变量也属于全局变量-->

<!--局部变量：	函数的形参也可以看做是局部变量-->

- 从执行效率看全局变量和局部变量
  - 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源
  - 局部变量  当我们程序执行完毕就会销毁， 比较节约内存资源



> ​	js中没有块级作用域  js的作用域： 全局作用域 局部作用域 现阶段我们js 没有块级作用域
>
> ​	js在es6的时候新增的块级作用域
>
> ​	块级作用域： {}      if{}   for{}

### 8.3 作用域链

> - 只要是代码，就至少有一个作用域
> - 写在函数内部的局部作用域
> - 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
> - 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称为  作用域链

<script>
    // 作用域链：  内部函数访问外部函数的变量，采取的事链式查询的方式来决定取哪个值 这种结构我们称为作用域链  （就近原则） 一层一层往外找  找到为止
    
    var num = 10;
    function fn(){ // 外部函数
		var num = 20;
        function fun(){  //内部函数
            console.log(num);
        }
    }
</script>



